## 数据的表示和存储

字节（Byte）是计算机中的最小存储单位

**Bit（位）**：是信息的最小单位，只能表示两种状态，通常是 `0` 或 `1`。

**Byte（字节）**：由 **8 个 bit** 组成。一个字节可以表示·`2^8 = 256`种不同的数值。

虽然 **bit 是信息的最小单位**，但在实际的**计算机系统中**，我们通常以 **字节（Byte）为最小的可寻址存储单元**，这是出于以下几个原因：

1. **硬件架构决定**

- 大多数 CPU 和内存的硬件设计都是以 **字节为单位**来访问数据。
- 比如，当你读取内存地址 `0x1000`，你读到的是一个 **字节**，而不是一个 bit。
- 现代计算机无法直接对单个位进行寻址（比如读取内存中的第 3 位），只能读取包含它的字节，再通过逻辑操作提取出特定位。

假设你要存储英文字符 `'A'`：

- 它的 ASCII 编码是 `65`，二进制是 `01000001`。
- 这是 8 个 bit，即 1 个字节。
- 内存中会占用一个完整的字节，而不是只使用一个 bit。





## 原码&反码&补码

### 原码

**原码**是一种用于表示**有符号整数**的编码方式。在原码表示法中，**数值的正负性由最高位（最左边的位）决定**。

原码最大值：`0111 1111`（+ 127）

原码最小值：`1111 1111`（- 127）

#### 缺点

1. **存在两个0**（+0 和 -0），处理麻烦。

2. **加减法不方便**，因为正数和负数的编码方式不同，不能像补码那样直接相加减。

在现代计算机中，**原码很少用于实际运算**，更多用于概念学习或特定场景。**计算机内部使用的是“补码”**，因为它能够统一加减法处理并消除两个0的问题。



### 反码

为了解决原码不能计算负数的问题

在反码中：

- **正数的反码 = 原码**
- **负数的反码 = 原码符号位不变，数值位按位取反（0变1，1变0）**

-56的原码：`1011 1000`

-56的反码：`1100 0111`





























